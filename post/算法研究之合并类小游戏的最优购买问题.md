```
本以为是个简单的问题，渐渐地变得复杂了起来。(剧透：暂时还没找到最优解法。)
```

## 题干

有12个格子用于存放游戏动物(joy)，每个 joy 有一个等级参数，最低为1级，最高为34级，合并格子内相同等级的 joy 可以获得一个高一等级的 joy，不同级别的 joy 不能合成。如果需要新的 joy 可以从商店购买，不同等级的 joy 价格不一样，并且会随着购买次数的增加，价格随之上涨。

现给出一张 joy 列表，也就是 12 个格子里的 joy 等级列表，以及商店的价格单，求下一个 joy 的最优购买等级。

*该题来源于京东的一个活动小游戏*

## 数据化问题

*本文使用程序语言为 javascript*

首先获取 joy 列表

``` js
// 假如获取到的列表为
let joyLists = [
  16,3,6,10,
  0,8,9,23,
  3,6,2,22
]
// 0 表示空格，可购买新的 joy 放置

// 然后因为有相同等级的 joy 先合并。合并不属于本文讨论范围，假设为
function merge(joyLists) {
  // 省略合并的具体代码
  return mergjoyLists
}

// 得到新的 joyLists 列表
joyLists = [
  16,3,0,10,
  0,8,9,23,
  3,7,2,22
]
```

为了简化到只针对最优购买的算法讨论，设置几个前提：
- 当前 joy 列表已没有可以合并的格子
- 可购买任意等级的 joy（算法是为了找出最优的购买价格/joy 等级）

### 问题分析

现在分析一下问题，首先得找到有几个空格是可以用来购买新的 joy。

``` js
// 找出 joyLists 中 0 的个数
function zeroNum(array){
  return array.filter(i=>i===0).length
}

let znum = zeroNum(joyLists)   // 2
```

然后分情况讨论，假如：
- 0个空格：直接退出，不需要购买新的 joy。
- 1个空格：这个时候简单来说，就是购买 joyLists 中最低等级的那一个，因为这样才能促进下一步的合成，不留下无法合成的 joy。
- 2个或以上的空格：这是本文讨论的重点。是买四个 1 合成两个 2，还是买两个1合成一个2，再买一个2，还是直接买两个 2？这种情况，简单想想，好像只要两个 1 的价格小于一个 2，就买两个1，反之就买 2。那么真的这么简单吗？

现在假设一种情况，只剩下两个空格。此时对应的商品价格为：

``` json
[
{"joyId":1,"coins":3000},     // joyId 表示等级，coins 表示价格
{"joyId":2,"coins":12000},
{"joyId":3,"coins":20000},
// ...
{"joyId":10,"coins":37200000},
// ...
]
```

我们要把 [0, 0] 这两个空格，花最小的价钱升级到目标等级，假设为 [3, 3]，这个时候该如何购买？
按照前面的简单算法，我们先买两个 1，合成一个2，再买一个 2，合成一个3，再买一个 3 达到目标等级。此时花费为：

```
3000*2 + 12000 + 20000 = 38000
// 购买第二个1时，价格会稍微上涨，这里为了方便，接连两次购买的上涨价格暂时忽略
```

直接购买两个3呢？花费为 20000\*2 = 40000，好像按之前的算法确实更好一些的？
（这里购买两个 3 的价格上涨，正好可以抵消购买两个 1 的价格上涨。实际上高等级的上涨幅度还大一些）

稍微修改一下，假如现在 1 的价格为 5000 呢？此时按之前的算法，总购买花费为：**5000\*2+12000+20000=42000**，这个时候 5000\*2 还是比 2 的 12000 要优惠 ，但确比直接购买两个 3 的花费（40000）要高。说明之前的简单想法有问题，算法需要调整。是购买 1 慢慢合成 3，还是直接购买 3呢？直观的感觉是，合成一个 3 需要 1 的个数是 4 (2的 3-1 次方)，那么是不是只要 1 价格的4倍比一个3的花费低就买1，反之就买3呢？

再回到之前的两个商品价格列表，第一次，1的价格为 3000，4倍为 12000，比3的价格 20000 确实低，计算结果也表示买1更划算。第二次，1的价格为 5000，4倍为 20000，和3的价格持平，那么应该花费是一样的，但实际结果是直接买3便宜了2000，问题出在哪？出在我们只有两个格子，无法买四个1，只能买两个1+一个2，不然格子装不下，会卡在 [1, 2] 这个阶段无法合成。多出来的 2000 来自于购买 2 的花费。

还有一种直观的想法是：只要高一等级的花费少于低一等级的2倍，那么就是直接购买高一等级的划算。有这个错误想法的回到最开始的商品价格列表看一下，高一等级（3）的花费（2000）少于低一等级（2）的两倍（12000\*2），但确是从1购买起最划算，而不是直接购买3。

## 算法设计

### 算法一：从1开始

有一个空格就买 joyLists 中等级最低的那个，有两个或以上的空格就全买等级为 1 的joy。这种方式最直接，不涉及到其他复杂的算法。代码如下：

``` js
function getBuyid(joyLists) {
  let znum = zeroNum(joyLists)

  if (znum === 0) {
    console.log('格子已满，无法购买新的 joy')
  } else if (znum === 1) {
    return Math.min(...joyLists.filter(s=>s))
  } else {
    return 1
  }
}

let buyid = getBuyid(joyLists)
```
*以上代码仅供参考，实际应用中需要根据情况进行简单调整*

适用情况：空格较多，低等级 joy 比较便宜，金钱相对较少的时候。

优点：简单，没有太多的计算，不用考虑价格的问题。

但缺点也很明显：
- 从算法上来说，再不断的买 1 的过程中，前面等级的 joy 价格会不断上升，而在后面的 joy 因为购买次数少，价格可能还比前面的更优惠，从而造成了浪费。
- 合成最高等级很慢，因为经常需要从 1 开始


### 算法二：从最高等级开始，比前面一级合适就买

当高等级的价格低于前面等级的 2 倍时，购买后面等级的。
（*这个算法从上面问题分析已经知道在某些特定情况下并不是最优解，但随着不断的购买，价格等级会趋向于理想化，还是有一定的实用价值*)

``` js
// 下面省略掉考虑 joyLists 空格数为 0/1 的情况（ 和算法一是一样的），只考虑空格数2个及以上的算法
function getBuyid2(joyPrices) {
  // joyLists 有2个及以上空格的处理
  let buyl = 0, 
      comp1 = joyPrices.pop(), comp2 = null    // 等待比较的两个 joy
  while(joyPrices.length) {
    comp2 = joyPrices.pop()
    if (comp1.coins < 2*comp2.coins) {
      // 找到符合条件的最高等级 joy 直接返回
      return comp1.joyId
    }
    comp1 = comp2  // 不符合则开始找下一个
  }
  return comp1.joyId
}

let buyid = getBuyid2(joyLists, joyPrices)
```
*以上代码仅供参考，实际应用中需要根据情况进行简单调整*

该算法适用于价格等级比较理想（前面的等级约是后面等级价格的一半），或者有新的购买等级解锁时，并且要求剩余金币较多，足够大量优先购买高等级 joy。

优点：优先从高等级开始购买，合成最高级速度很快。

缺点：花费较高，毕竟从高等级开始购买。

不适用的情况：当中间有某一个 joy 价格特别高时，比如10级 joy 3000万，而9级 joy 只要 100万，这种情况下10级以上的 joy 价格会被不断推高。比如只要 11 级的价格低于 6000万，就会购买 11 级，这样会进一步推高12的价格，以此类推，后面等级会指数级升高，很容易导致“破产”。

*2020.12.28 更新*
### 算法三：限定两个格子

先假设一种情况，在无限格子的情况下，全部买1，合成一个34级需要多久？（为了方便计算，忽略购买时间，并且假设合成一次花1秒。）合成1级花0秒，2级花1秒，3级花3秒（四个1合成两个2，两秒，两个2合成一个3，一秒），4级就是合成两个3的时间（3\*2 秒）+1秒（最后合成两个3），共7秒。类推可以得到一个公式，合成一个 **n** 级所需的时间为： **2^(n-1)-1**(2的n-1次方减1) 。那么合成一个34级的需要多久呢？根据公式计算可得，需要 **8589934591** 秒，等于 **2386092** 小时，等于 **272** 年，也就是说在这种情况下你不吃不喝，365天24小时每秒合成一次，全部从1开始合成一个34，需要272年。

再假设一种情况，在限定格子的情况下，极端一点只有2个格子，这时从1开始合成到34，需要多久？

```
[1,1] // 两个格子开始状态
[2,0] // 合成一次。然后不能继续购买1了，因为[2,1]会卡住。只能买2
[2,2]->[3,0] // 购买一次，合成一次
[3,3]->[4,0] // 继续购买一次，合成一次
。。。
```

按照这种情况合成一个34级，只需要合成33次，加上购买的32次，也就是差不多60多次就完成了。算1秒1次，一两分钟就搞定。从272年到一两分钟，只是限定了两个格子，觉得这个格子的限定还挺有意思的。
假如限定格子是12个，粗略的按指数增长模式简单计算一下，2^10=1024 分钟，17小时，差不多一两天就可以从1合成一个34。（本文计算都很粗糙，主要是为了表达算法思想。）
所以如果只考虑两个格子，不管其他格子能不能合成，有没有空格，要把其中一个升到最高级，只需要两分钟，然后再选另外两个格子继续把其中一个升到最高级，也只需要两分钟，以此类推，升10个最高级也只需要20分钟。

``` js
function getSp(joyLists){
  // 从 joyLists 选出两个空格作为限定格子
  let res = []
  for (let ind in joyLists) {
    if (joyLists[ind]===0) res.push(ind)
    if (res.length === 2) return res
  }
}

let sp = getSp(joyLists)   // 获取两个限定格子，分别为 sp[0], sp[1]
// let sp = [8, 9]         // 也可以直接指定两个格子（必须保证至少有一个是空格）
let maxL = 28              // 设置一下能购买的最高等级
let bFlag = 60             // 设置循环次数。（方便调试）

while(bFlag--) {
  if (joyLists[sp[0]] + joyLists[sp[1]] === 0) {
    // 如果限定格子上都是空的，就买1作为开始
    buyJoy(1)
  } else if (joyLists[sp[0]] === 0 || joyLists[sp[1]] === 0) {
    // 如果限定格子上有一个为空，就买另一个格子上的等级，方便进行下一步的合并
    let buyl = joyLists[sp[0]] || joyLists[sp[1]]
    if (buyl > maxL) break
    // 如果有一个格子的等级超过能购买的最高等级，说明任务完成，退出，留下一个空格（方便与其他格子再组一个限定组合）
    buyJoy(buyl)
  } else if (joyLists[sp[0]] === joyLists[sp[1]]) {
    // 如果两个都不为空，且等级相等，就进行合并
    mergeJoy(sp[0], sp[1])
  } else {
    // 两个不为空，且等级不等，说明有其他干扰，出现了卡住的情况
    break
  }
  joyLists = getJoyList()    // 每次变动之后，需要更新一下 joyLists 列表
}
```
*以上代码仅供参考，实际应用中需要根据情况进行简单调整*

优点：合成高等级 joy 很快

缺点：完全不考虑经济问题，每合成一个最高级都会把每个等级的 joy 购买一次，当高等级花费比较高时，很不划算。

适用情况：所有等级的价格特别理想（高一等级约是前一等级的2倍），且购买后上涨价格的比例没有太大变化。

使用建议：在有比较多金币剩余，且在使用算法二一段时间后（把价格调整得特别理想），设置较低一点的最高购买等级，针对特定几个格子短时间内使用。

## *未完，待续*

*情况比相像的要复杂很多，本以为花几个小时就研究完了，最后研究了一天，才发现自己竟然还找不到一个“最优”的解法。尝试归并/分治的算法，问题好像也不是那么简单，连空格的多少都会影响最优购买。唉，等有时间了再好好研究一下。*

### 后记

```
本来以为是个简单的小游戏，玩的时候没有多想，看到同等级的就合并，有空格了就买，仔细分析起来，发现太 TM 难了。（也可能是自己水平不够，继续学习吧。）
```

Author: https://t.me/elecV2