```
本以为是个简单的问题，渐渐地变得复杂了起来。(剧透：暂时还没找到最优解法。)
```

## 题干

有12个格子用于存放游戏动物(joy)，每个 joy 有一个等级参数，最低为1级，最高为34级，合并格子内相同等级的 joy 可以获得一个高一等级的 joy，不同级别的 joy 不能合成。如果需要新的 joy 可以从商店购买，不同等级的 joy 价格不一样，并且会随着购买次数的增加，价格随之上涨。

现给出一张 joy 列表，也就是 12 个格子里的 joy 等级列表，以及商店的价格单，求下一个 joy 的最优购买等级。

*该题来源于京东的一个活动小游戏*

## 数据化问题

*本文使用程序语言为 javascript*

首先获取 joy 列表

``` js
// 假如获取到的列表为
let joyLists = [
  16,3,6,10,
  0,8,9,23,
  3,6,2,22
]
// 0 表示空格，可购买新的 joy 放置

// 然后因为有相同等级的 joy 先合并。合并不属于本文讨论范围，假设为
function merge(joyLists) {
  // 省略合并的具体代码
  return mergjoyLists
}

// 得到新的 joyLists 列表
joyLists = [
  16,3,0,10,
  0,8,9,23,
  3,7,2,22
]
```

为了简化到只针对最优购买的算法讨论，设置几个前提：
- 当前 joy 列表已没有可以合并的格子
- 可购买任意等级的 joy（算法是为了找出最优的购买价格/joy 等级）

### 问题分析

现在分析一下问题，首先得找到有几个空格是可以用来购买新的 joy。

``` js
// 找出 joyLists 中 0 的个数
function zeroNum(array){
  return array.filter(i=>i===0).length
}

let znum = zeroNum(joyLists)   // 2
```

然后分情况讨论，假如：
- 0个空格：直接退出，不需要购买新的 joy。
- 1个空格：这个时候简单来说，就是购买 joyLists 中最低等级的那一个，因为这样才能促进下一步的合成，不留下无法合成的 joy。
- 2个或以上的空格：这是本文讨论的重点。是买四个 1 合成两个 2，还是买两个1合成一个2，再买一个2，还是直接买两个 2？这种情况，简单想想，好像只要两个 1 的价格小于一个 2，就买两个1，反之就买 2。那么真的这么简单吗？

现在假设一种情况，只剩下两个空格。此时的商品价格列表(joyPrices)为：

``` json
[
{"joyId":1,"coins":3000},     // joyId 表示等级，coins 表示价格
{"joyId":2,"coins":12000},
{"joyId":3,"coins":20000},
// ...
{"joyId":10,"coins":37200000},
// ...
]
```

我们要把 [0, 0] 这两个空格，花最小的价钱升级到目标等级，假设为 [3, 3]，这个时候该如何购买？
按照前面的简单算法，我们先买两个 1，合成一个2，再买一个 2，合成一个3，再买一个 3 达到目标等级。此时花费为：

```
3000*2 + 12000 + 20000 = 38000
// 购买第二个1时，价格会稍微上涨，这里为了方便，接连两次购买的上涨价格暂时忽略
```

直接购买两个3呢？花费为 20000\*2 = 40000，好像按之前的算法确实更好一些的？
（这里购买两个 3 的价格上涨，正好可以抵消购买两个 1 的价格上涨。实际上高等级的上涨幅度还大一些）

稍微修改一下，假如现在 1 的价格为 5000 呢？此时按之前的算法，总购买花费为：**5000\*2+12000+20000=42000**，这个时候 5000\*2 还是比 2 的 12000 要优惠 ，但确比直接购买两个 3 的花费（40000）要高。说明之前的简单想法有问题，算法需要调整。是购买 1 慢慢合成 3，还是直接购买 3呢？直观的感觉是，合成一个 3 需要 1 的个数是 4 (2的 3-1 次方)，那么是不是只要 1 价格的4倍比一个3的花费低就买1，反之就买3呢？

再回到之前的两个商品价格列表，第一次，1的价格为 3000，4倍为 12000，比3的价格 20000 确实低，计算结果也表示买1更划算。第二次，1的价格为 5000，4倍为 20000，和3的价格持平，那么应该花费是一样的，但实际结果是直接买3便宜了2000，问题出在哪？出在我们只有两个格子，无法买四个1，只能买两个1+一个2，不然格子装不下，会卡在 [1, 2] 这个阶段无法合成。多出来的 2000 来自于购买 2 的花费。

还有一种直观的想法是：只要高一等级的花费少于低一等级的2倍，那么就是直接购买高一等级的划算。有这个错误想法的回到最开始的商品价格列表看一下，高一等级（3）的花费（2000）少于低一等级（2）的两倍（12000\*2），但确是从1购买起最划算，而不是直接购买3。

## 算法设计

### 算法一：从1开始

有一个空格就买 joyLists 中等级最低的那个，有两个或以上的空格就全买1。这种方式最直接，不涉及到其他复杂的算法。代码如下：

``` js
function getBuyid(joyLists) {
  let znum = zeroNum(joyLists)

  if (znum === 0) {
    console.log('格子已满，无法购买新的 joy')
  } else if (znum === 1) {
    return Math.min(...joyLists.filter(s=>s))
  } else {
    return 1
  }
}

let buyid = getBuyid(joyLists)
```
*以上代码仅供参考，实际应用中需要根据情况进行简单调整*

适用情况：空格较多，低等级 joy 比较便宜，金钱相对较少的时候。

优点：简单，没有太多的计算，不用考虑价格的问题。

但缺点也很明显：
- 从算法上来说，再不断的买 1 的过程中，前面等级的 joy 价格会不断上升，而在后面的 joy 因为购买次数少，价格可能还比前面的更优惠，从而造成了浪费。
- 合成高等级很慢，因为经常需要从 1 开始

### 算法二：从最高等级开始，比前面一级合适就买

当高等级的价格低于前面等级的 2 倍时，就直接购买高等级的。
（*这个算法从上面问题分析已经知道在某些特定情况下并不是最优解，但随着不断的购买，价格等级会趋向于理想化，还是很有实用价值的*)

``` js
// 下面省略掉考虑 joyLists 空格数为 0/1 的情况（ 和算法一是一样的），只考虑空格数2个及以上的算法
function getBuyid2(joyPrices) {
  // joyLists 有2个及以上空格的处理
  let buyl = 0, 
      comp1 = joyPrices.pop(), comp2 = null    // 等待比较的两个 joy
  while(joyPrices.length) {
    comp2 = joyPrices.pop()
    if (comp1.coins < 2*comp2.coins) {
      // 找到符合条件的高等级 joy 直接返回
      return comp1.joyId
    }
    comp1 = comp2  // 不符合则开始找下一个
  }
  return comp1.joyId
}

let buyid = getBuyid2(joyPrices)
```
*以上代码仅供参考，实际应用中需要根据情况进行简单调整*

该算法适用于价格等级比较理想（前面的等级约是后面等级价格的一半），或者有新的购买等级解锁时，并且要求剩余金币较多，足够大量优先购买高等级 joy。

优点：优先从高等级开始购买，合成最高级速度较快。

缺点：花费较高，毕竟从高等级开始购买。

不适用的情况：当中间有某一个 joy 价格特别高时，比如10级 joy 3000万，而9级 joy 只要 100万，这种情况下10级以上的 joy 价格会被不断推高。比如只要 11 级的价格低于 6000万，就会购买 11 级，这样会进一步推高12的价格，以此类推，后面等级会指数级升高，很容易导致“破产”。

*2020.12.28 更新*
### 算法三：限定两个格子

先假设一种情况，在无限格子的情况下，全部买1，合成一个34级需要多久？（为了方便计算，忽略购买时间，并且假设合成一次花1秒。）合成1级花0秒，2级花1秒，3级花3秒（四个1合成两个2，两秒，两个2合成一个3，一秒），4级就是合成两个3的时间（3\*2 秒）+1秒（最后合成两个3），共7秒。类推可以得到一个公式，合成一个 **n** 级所需的时间为： **2^(n-1)-1**(2的n-1次方减1) 。那么合成一个34级的需要多久呢？根据公式计算可得，需要 **8589934591** 秒，等于 **2386092** 小时，等于 **272** 年，也就是说在这种情况下你不吃不喝，365天24小时每秒合成一次，全部从1开始合成一个34，需要272年。

再假设一种情况，在限定格子的情况下，极端一点只有2个格子，这时从1开始合成到34，需要多久？

```
[1,1] // 两个格子开始状态
[2,0] // 合成一次。然后不能继续购买1了，因为[2,1]会卡住。只能买2
[2,2]->[3,0] // 购买一次，合成一次
[3,3]->[4,0] // 继续购买一次，合成一次
。。。
```

按照这种情况合成一个34级，只需要合成33次，加上购买的32次，也就是差不多60多次就可以完成。算1秒1次，一两分钟就搞定。从272年到一两分钟，只是限定了两个格子，发现这个格子的限定还挺有意思的。
假如限定格子是12个，粗略的按指数增长模式简单计算一下，2^10=1024 分钟，17小时，差不多一两天就可以从1合成一个34。（本文计算都很粗糙，主要是为了表达算法思想。）
所以如果只考虑两个格子，不管其他格子能不能合成，有没有空格，要把其中一个升到最高级，只需要两分钟，然后再选另外两个格子继续把其中一个升到最高级，也只需要两分钟，以此类推，升10个最高级也只需要20分钟。

``` js
function getSp(joyLists){
  // 从 joyLists 选出两个空格作为限定格子
  let res = []
  for (let ind in joyLists) {
    if (joyLists[ind]===0) res.push(ind)
    if (res.length === 2) return res
  }
}

let sp = getSp(joyLists)   // 获取两个限定格子，分别为 sp[0], sp[1]
// let sp = [8, 9]         // 也可以直接指定两个格子（必须保证至少有一个是空格）
let maxL = 28              // 设置一下能购买的最高等级
let bFlag = 60             // 设置循环次数。（方便调试）

while(bFlag--) {
  if (joyLists[sp[0]] + joyLists[sp[1]] === 0) {
    // 如果限定格子上都是空的，就买1作为开始
    buyJoy(1)
  } else if (joyLists[sp[0]] === 0 || joyLists[sp[1]] === 0) {
    // 如果限定格子上有一个为空，就买另一个格子上的等级，方便进行下一步的合并
    let buyl = joyLists[sp[0]] || joyLists[sp[1]]
    if (buyl > maxL) break
    // 如果有一个格子的等级超过能购买的最高等级，说明任务完成，退出，留下一个空格（方便与其他格子再组一个限定组合）
    buyJoy(buyl)
  } else if (joyLists[sp[0]] === joyLists[sp[1]]) {
    // 如果两个都不为空，且等级相等，就进行合并
    mergeJoy(sp[0], sp[1])
  } else {
    // 两个不为空，且等级不等，说明有其他干扰，出现了卡住的情况
    break
  }
  joyLists = getJoyList()    // 每次变动之后，需要更新一下 joyLists 列表
}
```
*以上代码仅供参考，实际应用中需要根据情况进行简单调整*

优点：合成高等级 joy 很快

缺点：完全不考虑经济问题，每合成一个最高级都会把每个等级的 joy 购买一次，当高等级花费比较高时，很不划算。

适用情况：所有等级的价格特别理想（高一等级约是前一等级的2倍），且购买后上涨价格的比例没有太大变化。

使用建议：在有比较多金币剩余，且在使用算法二一段时间后（把价格调整得特别理想），设置较低一点的最高购买等级，针对特定几个格子短时间内使用。

*2020.12.29 更新*
### 算法四：两两比较获取商店里的最优商品

已两个1可以得到一个2，四个2可以得到一个4，可以得到一个简单的公式，获得一个 m 级 joy 需要 n 级 joy 的个数为：**2^(m-n)**(2的m-n次方)。比如：获取一个6级需要多少个3呢？2^(6-3)=8 个。那么我们可以简单的比较一下一个6便宜还是8个3便宜。当我们把商店里所有的等级两两比较之后就会获得一个最便宜的等级。

``` js
// 还是省略掉考虑空格数为0和1的部分，因为那个时候没得选
function getBuyid4(joyPrices) {
  let cl = joyPrices[0]         // 用于存放当前最便宜的购买等级
  for (let ind in joyPrices) {
    if (ind === 0) continue
    if (joyPrices[ind].coin < cl.coin * Math.pow(2, joyPrices[ind].joyId - cl.joyId)) {
      cl = joyPrices[ind]
    }
  }
  return cl.joyId
}
```
*以上代码仅供参考，实际应用中可能需要根据情况进行简单调整*

优点：理论上好像确实获得了一个“最优解”

缺点：
- 计算量大。每次都要把商店里所有的商品价格比较一遍，还涉及到一些指数运算。
- 完全没有考虑格子的限制。假如我们经过计算发现购买八个3确实比一个6便宜，但这时只有3个空格，实际情况如下：

```
[3,3,3]  // 购买三个3
[0,4,3]->[3,4,3]    // 合成一个4，补买一个3
[0,4,4]->[0,0,5]    // 合成一个4，继续合成一个5
[3,3,5]->[0,4,5]    // 补买两个3，合成一个4。这个时候，是没办法再继续买3了，只能买一个4
[4,4,5]->[0,5,5]->[0,0,6]   // 最后完成合并，得到一个6
```

我们购买了六个3以及一个4。当这个4的价格比两个3要贵很多时，可能比直接买一个6还要贵，而且更花时间。这只是拿3和6进行比较，当其中的跨度增大时，比如10级和22级，这种不确定性会进一步扩大。

适用情况：这个初看起来最“完美”的解法，其实是并不是很实用的，想不到一个比较适合的情况。

### 算法五：考虑格子限制的算法四优化版

假设有 s 个空格，只用 m 级 joy 可升到的最高等级(h)是多少？ **h = m+s-1**。比如3个空格，只用4级只升级到的最高级为：4+3-1=6。这个时候再拿4和7直接去比较就没有太大的意义，但如果不比较怎么知道哪一个更适合购买呢？那么这个时候就得计算出，强制在3个空格的时候用4升级到7具体花费是多少。简单的推算可以知道，在3个空格的时候4升级到7一共需要购买：六个4+一个5。现在只要比较一下六个4+一个5的价格和一个7的价格，就能知道哪一个更适合购买了。

现在的问题是要找到一个公式，计算出：在 s 个空格的时候由 m 升级到 n 需要的花费是多少？（以此来判断哪一个更适合购买。）

*稍微计算了一下，有点复杂，头疼。先到占个坑吧*
*感觉这个算法应该最接近最优解，但是这个公式，我算不出来啊！！！！*

// 以下为草稿，错的，直接忽略。给自己留的笔记
C(m+s-1) = 2^(s-1)\*P(m)
C(n) = 2^(s-1)\*P(m) + 2^(s-2)\*P(m) + ... + 2^(s-x)\*P(m); s-x >= 1 

*P(x): 表示 x 等级的价格，C(n): 合成 n 的花费*

这中间又产生了另外一个问题，其实从3级合成到7级有很多种方法。先买3合成一个6，然后可以直接买一个6合成7，也可以买先买两个5合成一个6再合成7，也可以先买两个4合成5再买5合成6再合成7。这还只是相差四级的买法，如果是相差10级/20级，合成的路径会成指数级增加，难道要计算出所有的买法然后进行一一比较？很明显，算力不允许啊。但不进行一一比较，无法确定哪个才是最优解啊。唉~ （想放弃，可能不会再更新了

### 算法六：直接花光所有金币（不求最好，但求最贵）

很早就想到了这种方法，但第一感觉太 low 了，很没有“水平”，于是没有写，等琢磨完上面的几种算法后，发现这种暴发户式的玩法，可能还蛮实用的。这种算法的主要思路就是：我现在就要花光我所有游戏币（因为留着游戏币确实也没什么用），在这个前提下获得尽可能多的高等级 joy。（写完之后发现，这个描述并不是很准确，还是不求最好，但求最贵准确一点。）

``` js
function getBuyid6(joyLists, joyPrices, totalCoins) {
  let znum = zeroNum(joyLists)     // 先获取空格数
  if (znum<=1) {
    // 省略空格数为0/1的代码
  } else {
    let buyl = 28         // 先设置一下初始最高购买等级，保留最后的理智
    while(buyl--){        // 从最高级开始计算能不能买
      if (joyPrices[buyl] && znum*joyPrices[buyl].coin < totalCoins) break
    }
    buyl = buyl || 1      // 保底1级
    while(znum--){        // 用能买到的最高级把空格填满
      buyJoy(buyl)
    }
  }
}
```
*以上代码仅供参考，实际应用中可能需要根据情况进行简单调整*

优点：合成高等级特别快

缺点：特花钱，尤其是在高等级特别贵的时候

适用情况：有大量金币剩余，且需要在短时间内快速获取高等级 joy 的时候。

## *未完，待续*

*情况比相像的要复杂很多，本以为花几个小时就研究完了，最后研究了一天，才发现自己竟然还找不到一个“最优”的解法。尝试归并/分治的算法，问题好像也不是那么简单，连空格的多少都会影响最优购买。唉，等有时间了再好好研究一下。*

### 后记

```
本来以为是个简单的小游戏，玩的时候没有多想，看到同等级的就合并，有空格了就买，仔细分析起来，发现太 TM 难了。（也可能是自己水平不够，继续学习吧。）
```

Author: https://t.me/elecV2