```
本以为是个简单的问题，渐渐地变得复杂了起来。
```

## 题干

有12个格子用于存放游戏动物(joy)，每个 joy 有一个等级参数，最低为1级，最高为34级，合并格子内相同等级的 joy 可以获得一个高一等级的 joy，不同级别的 joy 不能合成。如果需要新的 joy 可以从商店购买，不同等级的 joy 价格不一样，并且会随着购买次数的增加，价格随之上涨。

现给出一张 joy 列表，也就是 12 个格子里的 joy 等级列表，以及商店的价格单，求下一个 joy 的最优购买等级。

*该题来源于京东的一个活动小游戏*

## 数据化问题

*本文使用程序语言为 javascript*

首先获取 joy 列表

``` js
// 假如获取到的列表为
let joyLists = [
  16,3,6,10,
  0,8,9,23,
  3,6,2,22
]
// 0 表示空格，可购买新的 joy 放置

// 然后因为有相同等级的 joy 先合并。合并不属于本文讨论范围，假设为
function merge(joyLists) {
  // 省略合并的具体代码
  return mergjoyLists
}

// 得到新的 joyLists 列表
joyLists = [
  16,3,0,10,
  0,8,9,23,
  3,7,2,22
]
```

为了简化到只针对最优购买的算法讨论，设置几个前提：
- 当前 joy 列表已没有可以合并的格子
- 可购买任意等级的 joy（算法是为了找出最优的购买价格/joy 等级）

### 问题分析

现在分析一下问题，首先得找到有几个空格是可以用来购买新的 joy。

``` js
// 找出 joyLists 中 0 的个数
function zeroNum(array){
  return array.filter(i=>i===0).length
}

let znum = zeroNum(joyLists)   // 2
```

然后分情况讨论，假如：
0个空格：直接退出，不需要购买新的 joy。
1个空格：这个时候简单来说，就是购买 joyLists 中最低等级的那一个，因为这样才能促进下一步的合成，不留下无法合成的 joy。
2个或以上的空格：这是本文讨论的重点。是买四个 1 合成两个 2，还是买两个1合成一个2，再买一个2，还是直接买两个 2？这种情况，简单想想，好像只要两个 1 的价格小于一个 2，就买两个1，反之就买 2。那么真的这么简单吗？

现在假设一种情况，只剩下两个空格。此时对应的商品价格为：

``` json
[
{"joyId":1,"coins":3000},     // joyId 表示等级，coins 表示价格
{"joyId":2,"coins":12000},
{"joyId":3,"coins":20000},
// ...
{"joyId":10,"coins":37200000},
// ...
]
```

我们要把 [0, 0] 这两个空格，花最小的价钱升级到目标等级，假设为 [3, 3]，这个时候该如何购买？
按照前面的简单算法，我们先买两个 1，合成一个2，再买一个 2，合成一个3，再买一个 3 达到目标等级。此时花费为：

```
3000*2 + 12000 + 20000 = 38000
// 购买第二个1时，价格会稍微上涨，这里为了方便，接连两次购买的上涨价格暂时忽略
```

直接购买两个3呢？花费为 20000\*2 = 40000，好像按之前的算法确实更好一些的？
（这里购买两个 3 的价格上涨，正好可以抵消购买两个 1 的价格上涨。实际上高等级的上涨幅度还大一些）

稍微修改一下，假如现在 1 的价格为 5000 呢？此时按之前的算法，总购买花费为：**5000\*2+12000+20000=42000**，这个时候 5000\*2 还是比 2 的 12000 要优惠 ，但确比直接购买两个 3 的花费（40000）要高。说明之前的简单想法有问题，算法需要调整。是购买 1 慢慢合成 3，还是直接购买 3呢？直观的感觉是，合成一个 3 需要 1 的个数是 4 (2的 3-1 次方)，那么是不是只要 1 价格的4倍比一个3的花费低就买1，反之就买3呢？

再回到之前的两个商品价格列表，第一次，1的价格为 3000，4倍为 12000，比3的价格 20000 确实低，计算结果也表示买1更划算。第二次，1的价格为 5000，4倍为 20000，和3的价格持平，那么应该花费是一样的，但实际结果是直接买3便宜了2000，问题出在哪？出在我们只有两个格子，无法买四个1，只能买两个1+一个2，不然格子装不下，会卡在 [1, 2] 这个阶段无法合成。多出来的 2000 来自于购买 2 的花费。

还有一种直观的想法是：只要高一等级的花费少于低一等级的2倍，那么就是直接购买高一等级的划算。有这个错误想法的回到最开始的商品价格列表看一下，高一等级（3）的花费（2000）少于低一等级（2）的两倍（12000\*2），但确是从1购买起最划算，而不是直接购买3。

## 算法设计

### 算法一：从1开始

有一个空格就买 joyLists 中等级最低的那个，有两个或以上的空格就全买等级为 1 的joy。这种方式最直接，不涉及到其他复杂的算法。代码如下：

``` js
function getBuyid(joyLists) {
  let znum = zeroNum(joyLists)

  if (znum === 0) {
    console.log('格子已满，无法购买新的 joy')
  } else if (znum === 1) {
    return Math.min(...joyLists.filter(s=>s))
  } else {
    return 1
  }
}

let buyid = getBuyid(joyLists)
```

适用情况：空格较多，低等级 joy 比较便宜，金钱相对较少的时候。

优点：简单，没有太多的计算，不用考虑价格的问题，而且理论上最终格子里的 joy 都会升到能升的最高等级（如果金钱够的话）。

但缺点也很明显：
- 金钱是不可能够的。
- 从算法上来说，再不断的买 1 的过程中，前面等级的 joy 价格会不断上升，而在后面的 joy 因为购买次数少，价格可能还比前面的更优惠，从而造成了浪费。
- 合成最高等级很慢，因为经常需要从 1 开始


### 算法二：从最高等级开始，比前面一级合适就买

当高等级的价格低于前面等级的 2 倍时，购买后面等级的。
（*这个算法从上面问题分析已经知道在某些特定情况下并不是最优解，但随着不断的购买，价格等级会趋向于理想化，还是有一定的实用价值*)

``` js
// 下面省略掉考虑 joyLists 空格数为 0/1 的情况（ 和算法一是一样的），只考虑空格数2个及以上的算法
function getBuyid2(joyPrices) {
  // joyLists 有2个及以上空格的处理
  let buyl = 0, 
      comp1 = joyPrices.pop(), comp2 = null    // 等待比较的两个 joy
  while(joyPrices.length) {
    comp2 = joyPrices.pop()
    if (comp1.coins < 2*comp2.coins) {
      // 找到符合条件的最高等级 joy 直接返回
      return comp1.joyId
    }
    comp1 = comp2  // 不符合则开始找下一个
  }
  return comp1.joyId
}

let buyid = getBuyid2(joyLists, joyPrices)
```

该算法适用于价格等级比较理想（前面的等级约是后面等级价格的一半），或者有新的购买等级解锁时，并且要求剩余金币较多，足够大量优先购买高等级 joy。

优点：优先从高等级开始购买，合成最高级速度很快。

缺点：花费较高，毕竟从高等级开始购买。

不适用的情况：当中间有某一个 joy 价格特别高时，比如10级 joy 3000万，而9级 joy 只要 100万，这种情况下10级以上的 joy 价格会被不断推高。比如只要 11 级的价格低于 6000万，就会购买 11 级，这样会进一步推高12的价格，以此类推，后面等级会指数级升高，很容易导致“破产”。

## *未完，待续*

*情况比相像的要复杂很多，本以为花几个小时就研究完了，最后研究了一天，才发现自己竟然还找不到一个“最优”的解法。尝试归并/分治的算法，问题好像也不是那么简单，连空格的多少都会影响最优购买。唉，等有时间了再好好研究一下。*

### 后记

```
本来以为是个简单的小游戏，玩的时候没有多想，看到同等级的就合并，有空格了就买，仔细分析起来，发现太 TM 难了。（也可能是自己水平不够，继续学习吧。）
```

Author: https://t.me/elecV2