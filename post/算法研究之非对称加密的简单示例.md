```
发布日期：2022-04-28
最近更新：2022-04-28
本文链接：https://elecv2.github.io/#算法研究之非对称加密的简单示例

未完待续
```

### 前言

本文主要为记录一下学习加密解密的过程，方便加深理解，以及之后复习。如果其中出现了一些比较幼稚的地方，还望理解。

使用语言：nodejs

### 起因

现有的非对称加密都比较复杂，按照说明可能知道怎么用，多看看也能知道大概的逻辑，但总觉得很复杂。而且找到的资料大多数都是停留在理解和打比方的阶段，没有任何具体的实现。可以自己使用 JS 从 0 开始写一个非对称加密算法吗？具体如何实现呢？
有没有一种可能，自己可以设置一套简单的非对称加密算法，用于一些比较简单的、自定义的场景。

比如，自定义私钥 prikey: 'abcdefg', 通过某个算法生成一个公钥 pubkey: getPubKey('abcdefg'), 然后加密一段字符 enString: encrypt('hello elecV2P', pubkey)，通过私钥解密 decrypt(enString, prikey)。

### 学习

只有理解旧的，才（可能）创造新的。

关于 RSA 算法的说明文章

http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html

https://blog.csdn.net/qwe6112071/article/details/53576584

已知 RSA 或者非对称加密算法的缺点：

- 运算速度非常慢
- 加密字符有限

RSA 算法的核心在于两个质数相乘，当质数很大时，难以还原（并非不可能）。
在学习的过程中发现，所有算法都是基于数学，而这一点和字符串好像又没什么关系，我要加密的是一串字符，然后所有算法本质操作的都是数字？突然有了一点割裂感。有没有一种算法是直接对字符来进行操作的呢？

像 RSA 和 AES 等算法又是如何加密字符的呢？将字符转化为数字并不难，难的是确定使用哪种方式进行转化，不同的加密算法转化的方式都是一样的吗？还是会进行一些优化？

### 一个简单的对称加密算法

能想到的一个最简单的形式就是 **Buffer.from**

``` JS
const str = 'hello, elecV2';
const bfs = Buffer.from(str);

console.log(bfs, bfs.toString());
// <Buffer 68 65 6c 6c 6f 2c 20 65 6c 65 63 56 32> hello, elecV2
```

使用 Buffer 函数得到了一系列的数字，接下来就是对这一串数字进行加密，解密的问题。当然，实际常用的算法肯定不是这么简单，这里作了简化，方便学习和理解。

最简单的一种加密：给每个数字加一个特定值，解密时再减去即可。

``` JS
const en_key = 115;     // 用于加密的数字
const en_bfs = bfs.map(s=>s + en_key);
const de_bfs = en_bfs.map(s=>s - en_key);
console.log(
  '加密：', en_bfs,
  '\n解密：', de_bfs,
);
```

假如想使用一个字符串来进行加密呢？可以同样使用 Buffer 函数将字符串进行数字化，然后循环加上 Buffer 后的数字。

``` JS
const en_key_str = 'abcdefg';
const en_key_buf = Buffer.from(en_key_str);
let   en_key_idx = 0;
const en_bfs_str = bfs.map(s=>{
  const en_key = en_key_buf[en_key_idx++];
  // console.debug('en key:', en_key);
  if (en_key_idx >= en_key_buf.length) {
    en_key_idx = 0;
  }
  return s + en_key;
});
en_key_idx = 0;
const de_bfs_str = en_bfs_str.map(s=>{
  const en_key = en_key_buf[en_key_idx++];
  // console.debug('en key:', en_key);
  if (en_key_idx >= en_key_buf.length) {
    en_key_idx = 0;
  }
  return s - en_key;
});
console.log(
  '字符：', bfs,
  '\n密码：', en_key_buf,
  '\n加密：', en_bfs_str,
  '\n解密：', de_bfs_str,
);
```

最后，为了方便保存 Buffer 对象，还得知道两个转换函数：

``` JS
// 将 Buffer 内容以 base64 格式的字符串输出
const en_bfs_str_b64 = en_bfs_str.toString('base64');
// 也可以以 hex 格式输出，可能更直观一些
// const en_bfs_str_b64 = en_bfs_str.toString('hex');
// 将 base64 格式的字符串还原为 Buffer
const en_bfs_str_org = Buffer.from(en_bfs_str_b64, 'base64');

console.log(en_bfs_str_b64, en_bfs_str_org);
// ycfP0NSSh8bOyMe7mA== <Buffer c9 c7 cf d0 d4 92 87 c6 ce c8 c7 bb 98>
// c9c7cfd0d49287c6cec8c7bb98 <Buffer c9 c7 cf d0 d4 92 87 c6 ce c8 c7 bb 98>
```

至此，我们就得到一个简单的对称加密算法，完整代码如下：

``` JS
function ebufEncrypt(strorg, key = 'elecV2', encode = 'base64') {
  const bfs = Buffer.from(strorg);
  const en_key_buf = Buffer.from(key);
  let   en_key_idx = 0;
  const en_bfs_str = bfs.map(s=>{
    const en_key = en_key_buf[en_key_idx++];
    if (en_key_idx >= en_key_buf.length) {
      en_key_idx = 0;
    }
    return s + en_key;
  });
  return en_bfs_str.toString(encode);
}
/**
 * 基于 Buffer 的简单对称加密算法
 * Author  https://t.me/elecV2
 * @param  {string}  加密字符串
 * @param  {string}  加密密码
 * @param  {string}  加密后的字符串编码。可选 hex | base64
 * @return {string}  加密/解密后的字符串
 */
function ebufDecrypt(strb64, key = 'elecV2', encode = 'base64') {
  const en_bfs_str = Buffer.from(strb64, encode);
  const en_key_buf = Buffer.from(key);
  let   en_key_idx = 0;
  const de_bfs_str = en_bfs_str.map(s=>{
    const en_key = en_key_buf[en_key_idx++];
    if (en_key_idx >= en_key_buf.length) {
      en_key_idx = 0;
    }
    return s - en_key;
  });
  return de_bfs_str.toString();
}

// 测试
const passk = 'pass码';
const enstr = '你好，elecV2.';
const enb64 = ebufEncrypt(enstr, passk);
console.log(
  '加密前：', enstr, Buffer.from(enstr),
  '\n加密后：', enb64,
  '\n解密后：', ebufDecrypt(enb64, passk)
);
```

优点：

- 简单，容易理解。只涉及了加减运算
- 可以加密任意字符，而且长度不限
- 计算量小，能用。稍微改改还能对文件进行加密

缺点：

- 简单，容易破解。对大量的加密前后数据进行对比，还是比较容易得出加密密码的

可对加密方式进行一些优化：

- 比如打乱密码顺序（倒序，或特定其他序等）
- 对密码进行二次、多次加密（密码再加上或乘以其他值，或与后一个值进行某种操作）
- 对结果进行二次、多次加密
- 根据原始内容生成一些混淆参数
- 多组数据同时计算，提升效率

对以上算法进行各种修改，可以比较容易的写出一个适用于个人在某些特定情况下的算法。但这些优化并没有改变这个算法的本质，只是稍微稍微提高一点点破解的难度而已。

**理论上所有算法都是可以破解，只是难度的问题**

### 加密算法的安全性分析

一个加密算法主要包含两部分：**算法**，**密钥**。算法复杂，而密钥简单，比如密钥是 **12345678**，这个结果是很容易被碰撞出来的。如果密钥很复杂，而算法简单，比如只是简单使用密钥进行简单的加减运算，那么复杂的密钥也没有太大的意义。

分析一下上面算法的安全性。假如给你一串最终生成的 base64 加密字符串，比如：**0Ojo4OZ0Xl7ZmtLIpZeazMzKmt3WotniaVIWIsVTGMRMDPlK/+hMLf9ZENgU3i0VFBUU7wxKEtwZAvhbHvMfvMRb0idJ7fA=**，你需要花多少时间进行破解，得到原始数据，甚至推算出对应的密码？（加密函数就是上面的 **ebufEncrypt** 函数，并没有做任何优化更改）

这是一个已知算法，破解密钥的问题。目前所有有名的算法，算法都是已知的，只是不同情况下使用的密钥不同。在这个练习下，算法和密钥都比较简单，强烈建议自己先思考思考，并手动尝试尝试。

首先，这可能吗？如果没有使用这个算法和密钥生成大量数据来进行分析，好像不大可能反推出原始数据和密码。除非密钥很简单，比如 **12345678**，然后可以瞎碰出来。

那么需要给出多少组数据，才能比较方便的破解这个算法呢？（这也算是判断一个加密算法安全等级的重要标准。）

假如，给出一组数据

```
原始字符 hello elecV2, nice to meet yout.
加密输出 0Nng3OJalJvZkcOXW4Xazsa7UtzjlN3Yn6NP7Z3i2V0=
```

现在可以推算出密钥了吗？





最终答案：

```
原始字符为 https://elecv2.github.io/#算法研究之非对称加密的简单示例
加密密码为 https://t.me/elecV2
加密后字符 0Ojo4OZ0Xl7ZmtLIpZeazMzKmt3WotniaVIWIsVTGMRMDPlK/+hMLf9ZENgU3i0VFBUU7wxKEtwZAvhbHvMfvMRb0idJ7fA=
```

### 一个简单的非对称加密算法

